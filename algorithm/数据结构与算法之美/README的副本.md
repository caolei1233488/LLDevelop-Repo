## 《数据结构与算法之美》学习总结
- 入门篇
	- **[01 为什么要学习数据结构与算法](#01为什么要学习数据结构与算法)**
	- **[02 如何抓住重点，系统高效的学习数据结构与算法](#02如何抓住重点，系统高效的学习数据结构与算法)**
	- **[03 复杂度分析（上）: 如何分析、统计算法的执行效率和资源消耗](#03复杂度分析（上）)**
	- **[04 复杂度分析（下）: 浅析最好、最坏、平均、均摊时间复杂度](#04复杂度分析（下）)**
	- **[05 数组：为什么很多编程语言中数组都从0开始编号？](#05数组)**
	- **[05 数组：为什么很多编程语言中数组都从0开始编号？](#05)**
	- **[05 数组：为什么很多编程语言中数组都从0开始编号？](#05)**
	- **[05 数组：为什么很多编程语言中数组都从0开始编号？](#05)**
	- **[05 数组：为什么很多编程语言中数组都从0开始编号？](#05)**
	- **[05 数组：为什么很多编程语言中数组都从0开始编号？](#05)**
	- **[05 数组：为什么很多编程语言中数组都从0开始编号？](#05)**
	- **[05 数组：为什么很多编程语言中数组都从0开始编号？](#05)**
	- **[05 数组：为什么很多编程语言中数组都从0开始编号？](#05)**
	- **[05 数组：为什么很多编程语言中数组都从0开始编号？](#05)**
	- **[05 数组：为什么很多编程语言中数组都从0开始编号？](#05)**
	- **[05 数组：为什么很多编程语言中数组都从0开始编号？](#05)**
	- **[05 数组：为什么很多编程语言中数组都从0开始编号？](#05)**
	- **[05 数组：为什么很多编程语言中数组都从0开始编号？](#05)**
	- **[05 数组：为什么很多编程语言中数组都从0开始编号？](#05)**
	- **[05 数组：为什么很多编程语言中数组都从0开始编号？](#05)**
	- **[05 数组：为什么很多编程语言中数组都从0开始编号？](#05)**
	- **[05 数组：为什么很多编程语言中数组都从0开始编号？](#05)**
	- **[05 数组：为什么很多编程语言中数组都从0开始编号？](#05)**

### <a name="01为什么要学习数据结构与算法"></a> 01 为什么要学习数据结构与算法

- 一、数据结构和算法是什么
	- 1、数据结构是指一组数据的存储结构
	- 2、算法就是操作数据的方法
	- 3、数据结构和算法是相辅相成的，数据结构是为算法服务的，而算法要作用在特定的数据结构之上

- 二、学习的重点在什么地方

**数据结构和算法解决的是如何更省、更快地存储和处理数据的问题，因此，我们就需要一个考量效率和资源消耗的方法，这就是复杂度分析方法。在学习数据结构和算法的过程中，要学习它的「来历」、「自身的特点」、「适合解决的问题」以及「实际的应用场景」。**

- 1、数据结构和算法学习的精髓-复杂度分析
- 2、最常用的、最基础的数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树
- 3、最常用的算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法


### <a name="02如何抓住重点，系统高效的学习数据结构与算法"></a> 02 如何抓住重点，系统高效的学习数据结构与算法

- 事半功倍的学习技巧
	- 1、边学边练，适度刷题
		- 每周花几个小时时间，集中将这周的学习的内容自己写出来实现一遍，效果会好很多，禁忌走马观花 	
	- 2、多问、多思考、多互动、形成学习小组氛围
		- 学习最好的方法是，找到几个人一起学习，一块儿讨论切磋，有问题及时寻求老师答疑。
	- 3、打怪升级学习法
		- 每个阶段设立切实可行的目标
	- 4、知识需要沉淀，不要想试图一下子掌握所有
		- 学习知识的过程是反复迭代、不断沉淀的过程

### <a name="03复杂度分析（上）"></a> 03 复杂度分析（上）: 如何分析、统计算法的执行效率和资源消耗

-  一、什么是复杂度分析
	- 1.数据结构和算法解决是“如何让计算机更快时间、更省空间的解决问题”。
	- 2.因此需从执行时间和占用空间两个维度来评估数据结构和算法的性能。
	- 3.分别用时间复杂度和空间复杂度两个概念来描述性能问题，二者统称为复杂度。
	- 4.复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系。
- 二、为什么要进行复杂度分析	
	- 1.和性能测试相比，复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强的特点。
	- 2.掌握复杂度分析，将能编写出性能更优的代码，有利于降低系统开发和维护成本。
- 三、如何进行复杂度分析
	- 1.大O表示法
		- 1）来源: 算法的执行时间与每行代码的执行次数成正比，用T(n) = O(f(n))表示，其中T(n)表示算法执行总时间，f(n)表示每行代码执行总次数，而n往往表示数据的规模。
		- 2）特点 : 以时间复杂度为例，由于时间复杂度描述的是算法执行时间与数据规模的增长变化趋势，所以常量阶、低阶以及系数实际上对这种增长趋势不产决定性影响，所以在做时间复杂度分析时忽略这些项。
		
	- 2.复杂度分析法则
		- 1）单段代码看高频：比如循环。
		- 2）多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。
		- 3）嵌套代码求乘积：比如递归、多重循环等
		- 4）多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。

- 四、常用的复杂度级别？
	- 多项式阶：随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。包括，
O(1)（常数阶）、O(logn)（对数阶）、O(n)（线性阶）、O(nlogn)（线性对数阶）、O(n^2)（平方阶）、O(n^3)（立方阶）
	- 非多项式阶：随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。包括，O(2^n)（指数阶）、O(n!)（阶乘阶）

- 五、如何掌握好复杂度分析方法？
	- 复杂度分析关键在于多练，所谓孰能生巧

### <a name="04复杂度分析（下）"></a> 04 复杂度分析（下）: 浅析最好、最坏、平均、均摊时间复杂度

- 一、复杂度分析的4个概念
	- 1.最坏情况时间复杂度：代码在最坏情况下执行的时间复杂度。	- 2.最好情况时间复杂度：代码在最理想情况下执行的时间复杂度。
	- 3.平均时间复杂度：用代码在所有情况下执行的次数的加权平均值表示。
	- 4.均摊时间复杂度：在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级别复杂度且发生具有时序关系时，可以将个别高级别复杂度均摊到低级别复杂度上。基本上均摊结果就等于低级别复杂度。

- 二、为什么要引入这4个概念？
	- 1.同一段代码在不同情况下时间复杂度会出现量级差异，为了更全面，更准确的描述代码的时间复杂度，所以引入这4个概念。
	- 2.代码复杂度在不同情况下出现量级差别时才需要区别这四种复杂度。大多数情况下，是不需要区别分析它们的。

- 三、如何分析平均、均摊时间复杂度？
	- 1.平均时间复杂度
		- 代码在不同情况下复杂度出现量级差别，则用代码所有可能情况下执行次数的加权平均值表示。
	- 2.均摊时间复杂度
		- 两个条件满足时使用：1）代码在绝大多数情况下是低级别复杂度，只有极少数情况是高级别复杂度；2）低级别和高级别复杂度出现具有时序规律。均摊结果一般都等于低级别复杂度。


### <a name="05数组"></a> 05 数组：为什么很多编程语言中数组都从0开始编号？

- 什么是数组
	- 【数组】：数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。
		- 【线性表】：线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。数组、链表、队列、栈等也是线性表结构。
		- 【非线性表】：在非线性表中，数据之间并不是简单的前后关系；二叉树、堆、图；
		- 【连续的内存空间和相同类型数据】使得具有随机访问的特性，缺点：删除和插入数据效率很低

![数组地址图](https://static001.geekbang.org/resource/image/98/c4/98df8e702b14096e7ee4a5141260cdc4.jpg)

随机访问数组中的某个元素是：它会首先通过下面的寻址公式，计算出该元素存储的内存地址：

```
a[i]_address = base_address + i * data_type_size
```


- 数组和链表的区别
	- 	数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。数组的查找操作时间复杂度并不是O(1)。即便是排好的数组，用二分查找，时间复杂度也是O（logn）
	-  “链表适合插入、删除，时间复杂度 O(1);
		
- 警惕数组的访问越界问题

数组越界在 C 语言中是一种未决行为，并没有规定数组访问越界时编译器应该如何处理。因为，访问数组的本质就是访问一段连续内存，只要数组通过偏移计算得到的内存地址是可用的，那么程序就可能不会报任何错误。

- Array 和 数组相比的优势
	- 	可以将很多数组操作的细节封装起来
	-  就是支持动态扩容。
	-  因为扩容操作涉及内存申请和数据搬移，最好在创建 ArrayList 的时候事先指定数据大小。


### <a name="06"></a> 06 链表（上）：如何实现LRU缓存淘汰算法?？
### <a name="07"></a> 07 链表（下）：如何轻松写出正确的链表代码？
### <a name="08"></a> 08 栈：如何实现浏览器的前进和后退功能？
### <a name="09"></a> 09 队列：队列在线程池等有限资源池中的应用
### <a name="10"></a> 10 递归：如何用三行代码找到“最终推荐人”？
### <a name="11"></a> 11 排序（上）：为什么插入排序比冒泡排序更受欢迎？
### <a name="12"></a> 12 排序（下）：如何用快排思想在O(n)内查找第K大元素？
### <a name="13"></a> 13 线性排序：如何根据年龄给100万用户数据排序？

### <a name="14"></a> 14 排序优化：如何实现一个通用的、高性能的排序函数？
### <a name="15"></a> 15 二分查找（上）：如何用最省内存的方式实现快速查找功能？
### <a name="16"></a> 16 二分查找（下）：如何快速定位IP对应的省份地址？
### <a name="17"></a> 17 跳表：为什么Redis一定要用跳表来实现有序集合？
### <a name="18"></a> 18 散列表（上）：Word文档中的单词拼写检查功能是如何实现的？
### <a name="19"></a> 19 散列表（中）：如何打造一个工业级水平的散列表
### <a name="20"></a> 20 散列表（下）：为什么散列表和链表经常会一起使用？

### <a name="21"></a> 21 哈希算法（上）：如何防止数据库中的用户信息被脱库？

### <a name="22"></a> 22 哈希算法（下）：哈希算法在分布式系统中有哪些应用？
### <a name="23"></a> 23 二叉树基础（上）：什么样的二叉树适合用数组来存储？

### <a name="24"></a> 24 二叉树基础（下）：有了如此高效的散列表，为什么还需要二叉树？
### <a name="25"></a> 25 红黑树（上）：为什么工程中都用红黑树这种二叉树？
### <a name="26"></a> 26 红黑树（下）：掌握这些技巧，你也可以实现一个红黑树
### <a name="27"></a> 27 递归树：如何借助树来求解递归算法的时间复杂度？

### <a name="28"></a> 28 堆和堆排序：为什么说堆排序没有快速排序快？

### <a name="29"></a> 29 堆的应用：如何快速获取到Top 10最热门的搜索关键词？
### <a name="30"></a> 30 图的表示：如何存储微博、微信等社交网络中的好友关系？
### <a name="31"></a> 31 深度和广度优先搜索：如何找出社交网络中的三度好友关系？

### <a name="32"></a> 32 字符串匹配基础（上）：如何借助哈希算法实现高效字符串匹配？

### <a name="33"></a> 33 字符串匹配基础（中）：如何实现文本编辑器中的查找功能？

### <a name="34"></a> 34 字符串匹配基础（下）：如何借助BM算法轻松理解KMP算法

### <a name="35"></a> 35 Trie树：如何实现搜索引擎的搜索关键词提示功能？

### <a name="36"></a> 36 AC自动机：如何用多模式串匹配实现敏感词过滤功能

### <a name="37"></a> 37 贪心算法：如何用贪心算法实现Huffman压缩编码？

### <a name="38"></a> 38 分治算法：谈一谈大规模计算框架MapReduce中的分治思想


### <a name="39"></a> 39 回溯算法：从电影《蝴蝶效应》中学习回溯算法的核心思想


### <a name="40"></a> 40 初识动态规划：如何巧妙解决“双十一”购物时的凑单问题？


### <a name="41"></a> 41 动态规划理论：一篇文章带你彻底搞懂最优子结构、无后效性和重复子问题


### <a name="42"></a> 42 动态规划实战：如何实现搜索引擎中的拼写纠错功能？





		
		