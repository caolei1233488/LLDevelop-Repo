## 《数据结构与算法之美》学习总结
- 入门篇
	- **[01 为什么要学习数据结构与算法](#01为什么要学习数据结构与算法)**
	- **[02 如何抓住重点，系统高效的学习数据结构与算法](#02如何抓住重点，系统高效的学习数据结构与算法)**
	- **[03 复杂度分析（上）: 如何分析、统计算法的执行效率和资源消耗](#03复杂度分析（上）)**
	- **[04 复杂度分析（下）: 浅析最好、最坏、平均、均摊时间复杂度](#04复杂度分析（下）)**
	- **[05 数组：为什么很多编程语言中数组都从0开始编号？](#05数组)**
	- **[06 链表（上）：如何实现LRU缓存淘汰算法?](#06)**
	- **[07 链表（下）：如何轻松写出正确的链表代码？](#07)**
	- **[08 栈：如何实现浏览器的前进和后退功能？](#08)**
	- **[09 队列：队列在线程池等有限资源池中的应用](#09)**
	- **[10 递归：如何用三行代码找到“最终推荐人”？](#10)**
	- **[11 排序（上）：为什么插入排序比冒泡排序更受欢迎？](#11)**
	- **[12 排序（下）：如何用快排思想在O(n)内查找第K大元素？](#12)**
	- **[13 线性排序：如何根据年龄给100万用户数据排序？](#13)**
	- **[14 排序优化：如何实现一个通用的、高性能的排序函数？](#14)**
	- **[15 二分查找（上）：如何用最省内存的方式实现快速查找功能？](#15)**
	- **[16 二分查找（下）：如何快速定位IP对应的省份地址？](#16)**
	- **[17 跳表：为什么Redis一定要用跳表来实现有序集合？](#17)**
	- **[18 散列表（上）：Word文档中的单词拼写检查功能是如何实现的？](#18)**
	- **[19 散列表（中）：如何打造一个工业级水平的散列表](#19)**
	- **[20 散列表（下）：为什么散列表和链表经常会一起使用？](#20)**
	- **[21 哈希算法（上）：如何防止数据库中的用户信息被脱库？](#21)**
	- **[22 哈希算法（下）：哈希算法在分布式系统中有哪些应用？](#22)**
	- **[23 二叉树基础（上）：什么样的二叉树适合用数组来存储？](#23)**
	- **[24 二叉树基础（下）：有了如此高效的散列表，为什么还需要二叉树？](#24)**
	- **[25 红黑树（上）：为什么工程中都用红黑树这种二叉树？](#25)**
	- **[26 红黑树（下）：掌握这些技巧，你也可以实现一个红黑树](#26)**
	- **[27 递归树：如何借助树来求解递归算法的时间复杂度？](#27)**
	- **[28 堆和堆排序：为什么说堆排序没有快速排序快？](#28)**
	- **[29 堆的应用：如何快速获取到Top 10最热门的搜索关键词？](#29)**
	- **[30 图的表示：如何存储微博、微信等社交网络中的好友关系？](#30)**
	- **[31 深度和广度优先搜索：如何找出社交网络中的三度好友关系？](#31)**
	- **[32 字符串匹配基础（上）：如何借助哈希算法实现高效字符串匹配？](#32)**
	- **[33 字符串匹配基础（中）：如何实现文本编辑器中的查找功能？](#33)**
	- **[34 字符串匹配基础（下）：如何借助BM算法轻松理解KMP算法](#34)**
	- **[35 Trie树：如何实现搜索引擎的搜索关键词提示功能？](#35)**
	- **[36 AC自动机：如何用多模式串匹配实现敏感词过滤功能](#36)**
	- **[37 贪心算法：如何用贪心算法实现Huffman压缩编码？](#37)**
	- **[38 分治算法：谈一谈大规模计算框架MapReduce中的分治思想](#38)**
	- **[39 回溯算法：从电影《蝴蝶效应》中学习回溯算法的核心思想](#39)**
	- **[40 初识动态规划：如何巧妙解决“双十一”购物时的凑单问题？](#40)**
	- **[41 动态规划理论：一篇文章带你彻底搞懂最优子结构、无后效性和重复子问题](#41)**
	- **[42 动态规划实战：如何实现搜索引擎中的拼写纠错功能？](#42)**

### <a name="01为什么要学习数据结构与算法"></a> 01 为什么要学习数据结构与算法

- 一、数据结构和算法是什么
	- 1、数据结构是指一组数据的存储结构
	- 2、算法就是操作数据的方法
	- 3、数据结构和算法是相辅相成的，数据结构是为算法服务的，而算法要作用在特定的数据结构之上

- 二、学习的重点在什么地方

**数据结构和算法解决的是如何更省、更快地存储和处理数据的问题，因此，我们就需要一个考量效率和资源消耗的方法，这就是复杂度分析方法。在学习数据结构和算法的过程中，要学习它的「来历」、「自身的特点」、「适合解决的问题」以及「实际的应用场景」。**

- 1、数据结构和算法学习的精髓-复杂度分析
- 2、最常用的、最基础的数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树
- 3、最常用的算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法


### <a name="02如何抓住重点，系统高效的学习数据结构与算法"></a> 02 如何抓住重点，系统高效的学习数据结构与算法

- 事半功倍的学习技巧
	- 1、边学边练，适度刷题
		- 每周花几个小时时间，集中将这周的学习的内容自己写出来实现一遍，效果会好很多，禁忌走马观花 	
	- 2、多问、多思考、多互动、形成学习小组氛围
		- 学习最好的方法是，找到几个人一起学习，一块儿讨论切磋，有问题及时寻求老师答疑。
	- 3、打怪升级学习法
		- 每个阶段设立切实可行的目标
	- 4、知识需要沉淀，不要想试图一下子掌握所有
		- 学习知识的过程是反复迭代、不断沉淀的过程

### <a name="03复杂度分析（上）"></a> 03 复杂度分析（上）: 如何分析、统计算法的执行效率和资源消耗

-  一、什么是复杂度分析
	- 1.数据结构和算法解决是“如何让计算机更快时间、更省空间的解决问题”。
	- 2.因此需从执行时间和占用空间两个维度来评估数据结构和算法的性能。
	- 3.分别用时间复杂度和空间复杂度两个概念来描述性能问题，二者统称为复杂度。
	- 4.复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系。
- 二、为什么要进行复杂度分析	
	- 1.和性能测试相比，复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强的特点。
	- 2.掌握复杂度分析，将能编写出性能更优的代码，有利于降低系统开发和维护成本。
- 三、如何进行复杂度分析
	- 1.大O表示法
		- 1）来源: 算法的执行时间与每行代码的执行次数成正比，用T(n) = O(f(n))表示，其中T(n)表示算法执行总时间，f(n)表示每行代码执行总次数，而n往往表示数据的规模。
		- 2）特点 : 以时间复杂度为例，由于时间复杂度描述的是算法执行时间与数据规模的增长变化趋势，所以常量阶、低阶以及系数实际上对这种增长趋势不产决定性影响，所以在做时间复杂度分析时忽略这些项。
		
	- 2.复杂度分析法则
		- 1）单段代码看高频：比如循环。
		- 2）多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。
		- 3）嵌套代码求乘积：比如递归、多重循环等
		- 4）多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。

- 四、常用的复杂度级别？
	- 多项式阶：随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。包括，
O(1)（常数阶）、O(logn)（对数阶）、O(n)（线性阶）、O(nlogn)（线性对数阶）、O(n^2)（平方阶）、O(n^3)（立方阶）
	- 非多项式阶：随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。包括，O(2^n)（指数阶）、O(n!)（阶乘阶）

- 五、如何掌握好复杂度分析方法？
	- 复杂度分析关键在于多练，所谓孰能生巧

### <a name="04复杂度分析（下）"></a> 04 复杂度分析（下）: 浅析最好、最坏、平均、均摊时间复杂度

- 一、复杂度分析的4个概念
	- 1.最坏情况时间复杂度：代码在最坏情况下执行的时间复杂度。	- 2.最好情况时间复杂度：代码在最理想情况下执行的时间复杂度。
	- 3.平均时间复杂度：用代码在所有情况下执行的次数的加权平均值表示。
	- 4.均摊时间复杂度：在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级别复杂度且发生具有时序关系时，可以将个别高级别复杂度均摊到低级别复杂度上。基本上均摊结果就等于低级别复杂度。

- 二、为什么要引入这4个概念？
	- 1.同一段代码在不同情况下时间复杂度会出现量级差异，为了更全面，更准确的描述代码的时间复杂度，所以引入这4个概念。
	- 2.代码复杂度在不同情况下出现量级差别时才需要区别这四种复杂度。大多数情况下，是不需要区别分析它们的。

- 三、如何分析平均、均摊时间复杂度？
	- 1.平均时间复杂度
		- 代码在不同情况下复杂度出现量级差别，则用代码所有可能情况下执行次数的加权平均值表示。
	- 2.均摊时间复杂度
		- 两个条件满足时使用：1）代码在绝大多数情况下是低级别复杂度，只有极少数情况是高级别复杂度；2）低级别和高级别复杂度出现具有时序规律。均摊结果一般都等于低级别复杂度。


### <a name="05数组"></a> 05 数组：为什么很多编程语言中数组都从0开始编号？

- 什么是数组
	- 【数组】：数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。
		- 【线性表】：线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。数组、链表、队列、栈等也是线性表结构。
		- 【非线性表】：在非线性表中，数据之间并不是简单的前后关系；二叉树、堆、图；
		- 【连续的内存空间和相同类型数据】使得具有随机访问的特性，缺点：删除和插入数据效率很低

![数组地址图](https://static001.geekbang.org/resource/image/98/c4/98df8e702b14096e7ee4a5141260cdc4.jpg)

随机访问数组中的某个元素是：它会首先通过下面的寻址公式，计算出该元素存储的内存地址：

```
a[i]_address = base_address + i * data_type_size
```


- 数组和链表的区别
	- 	数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。数组的查找操作时间复杂度并不是O(1)。即便是排好的数组，用二分查找，时间复杂度也是O（logn），数组的插入和删除操作是，时间复杂度O(n)
	-  “链表适合插入、删除，时间复杂度 O(1);
		
- 警惕数组的访问越界问题

数组越界在 C 语言中是一种未决行为，并没有规定数组访问越界时编译器应该如何处理。因为，访问数组的本质就是访问一段连续内存，只要数组通过偏移计算得到的内存地址是可用的，那么程序就可能不会报任何错误。

- Array 和 数组相比的优势
	- 	可以将很多数组操作的细节封装起来
	-  就是支持动态扩容。
	-  因为扩容操作涉及内存申请和数据搬移，最好在创建 ArrayList 的时候事先指定数据大小。


### <a name="06"></a> 06 链表（上）：如何实现LRU缓存淘汰算法?

- 常见的缓存策略
	- 先进先出策略 FIFO（First In，First Out）
	- 最少使用策略 LFU（Least Frequently Used）
	- 最近最少使用策略 LRU（Least Recently Used）。
- 数组和链表申请内存的区别
	- 	数组需要一块连续的内存空间来存储，对内存的要求比较高。我们申请一个 100MB 大小的数组，当内存中没有连续的、足够大的存储空间时，即便内存的剩余总可用空间大于 100MB，仍然会申请失败
	-  链表恰恰相反，它并不需要一块连续的内存空间，它通过“指针”将一组零散的内存块串联起来使用，所以如果我们申请的是 100MB 大小的链表，根本不会有问题。

![数组和链表内存分部图](https://static001.geekbang.org/resource/image/d5/cd/d5d5bee4be28326ba3c28373808a62cd.jpg)


- 单链表
	- 头结点：第一个节点
	- 尾结点：最后一个节点 指向空地址null
![单链表](https://static001.geekbang.org/resource/image/b9/eb/b93e7ade9bb927baad1348d9a806ddeb.jpg)	
	- 插入和删除的时间复杂点是O(1); 
	- 但是链表的随机访问性能没有数组好，需要O(n)的时间复杂度 

- 循环链表
	- 	循环链表是一种特殊的单链表，循环链表的尾结点指针是指向链表的头结点
![循环列表](https://static001.geekbang.org/resource/image/86/55/86cb7dc331ea958b0a108b911f38d155.jpg)
	- 循环链表的优点是从链尾到链头比较方便: 当要处理的数据具有环型结构特点时，就特别适合采用循环链表

- 双向链表
	- 双向链表： 它支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。 	
![双向链表](https://static001.geekbang.org/resource/image/cb/0b/cbc8ab20276e2f9312030c313a9ef70b.jpg)
	- 双向链表需要额外的两个空间来存储后继结点和前驱结点的地址，如果存储同样多的数据，双向链表要比单链表占用更多的内存空间。但可以支持双向遍历，这样也带来了双向链表操作的灵活性
	- 删除结点中“值等于某个给定值”的结点：
		- 则单链表和双链表都需要遍历，然后删除，时间复杂度为O(n)
	- 删除给定指针指向的节点
		- 找到了要删除的结点，但是删除某个结点 q 需要知道其前驱结点，而单链表并不支持直接获取前驱结点，双链表保存了前驱节点
		- 此种情况 单链表时间复杂度：O(n), 双向链表时间负责度O(1);

- 双向循环列表
	- 将循环列表和双向列表整合到一期就是双向循环列表
![双向循环列表](https://static001.geekbang.org/resource/image/d1/91/d1665043b283ecdf79b157cfc9e5ed91.jpg)
 
- 链表 VS 数组性能大比拼
	- 正是因为内存存储的区别，他们插入、删除、随机访问操作的时间复杂度刚好相反
![链表 VS 数组性能大比拼](https://static001.geekbang.org/resource/image/4f/68/4f63e92598ec2551069a0eef69db7168.jpg)
	- 访问效率
		-  数组是联系的内存空间，可以借助CPU的缓存机制，预读数组中的数据，所以访问效率更高。
		-  链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。
   - 存储大小
	   - 数组的缺点是大小固定，分配数组不够用时，导致内存不足，动态申请，需要将原有数据内容copy到新数组里边，非常费时
	   - 链表没有大小的限制
- CPU缓存机制
	- CPU在从内存读取数据的时候，会先把读取到的数据加载到CPU的缓存中。而CPU每次从内存读取数据并不是只读取那个特定要访问的地址，而是读取一个数据块并保存到CPU缓存中，然后下次访问内存数据的时候就会先从CPU缓存开始查找，如果找到就不需要再从内存中取。这样就实现了比内存访问速度更快的机制，也就是CPU缓存存在的意义:为了弥补内存访问速度过慢与CPU执行速度快之间的差异而引入。 	
	
- 如果你的代码对内存使用非常苛刻，则使用数组，链表存储节点导致内存消耗double，而且对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片		
- 如何基于链表实现LRU缓存淘汰算法
	- 维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当一个新的数据访问时，我们从链表头开始顺序遍历链表
	- 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。
	- 如果此数据没有在缓存链表中，又可以分为两种情况：
		- 如果此时缓存未满，则将此结点直接插入到链表的头部；
		- 如果此时缓存已经满了，则将链表最后一个节点删除，将新的数据节点插入链表的头部；  	

### <a name="07"></a> 07 链表（下）：如何轻松写出正确的链表代码？
### <a name="08"></a> 08 栈：如何实现浏览器的前进和后退功能？
### <a name="09"></a> 09 队列：队列在线程池等有限资源池中的应用
### <a name="10"></a> 10 递归：如何用三行代码找到“最终推荐人”？
### <a name="11"></a> 11 排序（上）：为什么插入排序比冒泡排序更受欢迎？
### <a name="12"></a> 12 排序（下）：如何用快排思想在O(n)内查找第K大元素？
### <a name="13"></a> 13 线性排序：如何根据年龄给100万用户数据排序？

### <a name="14"></a> 14 排序优化：如何实现一个通用的、高性能的排序函数？
### <a name="15"></a> 15 二分查找（上）：如何用最省内存的方式实现快速查找功能？
### <a name="16"></a> 16 二分查找（下）：如何快速定位IP对应的省份地址？
### <a name="17"></a> 17 跳表：为什么Redis一定要用跳表来实现有序集合？
### <a name="18"></a> 18 散列表（上）：Word文档中的单词拼写检查功能是如何实现的？
### <a name="19"></a> 19 散列表（中）：如何打造一个工业级水平的散列表
### <a name="20"></a> 20 散列表（下）：为什么散列表和链表经常会一起使用？

### <a name="21"></a> 21 哈希算法（上）：如何防止数据库中的用户信息被脱库？

### <a name="22"></a> 22 哈希算法（下）：哈希算法在分布式系统中有哪些应用？
### <a name="23"></a> 23 二叉树基础（上）：什么样的二叉树适合用数组来存储？

### <a name="24"></a> 24 二叉树基础（下）：有了如此高效的散列表，为什么还需要二叉树？
### <a name="25"></a> 25 红黑树（上）：为什么工程中都用红黑树这种二叉树？
### <a name="26"></a> 26 红黑树（下）：掌握这些技巧，你也可以实现一个红黑树
### <a name="27"></a> 27 递归树：如何借助树来求解递归算法的时间复杂度？

### <a name="28"></a> 28 堆和堆排序：为什么说堆排序没有快速排序快？

### <a name="29"></a> 29 堆的应用：如何快速获取到Top 10最热门的搜索关键词？
### <a name="30"></a> 30 图的表示：如何存储微博、微信等社交网络中的好友关系？
### <a name="31"></a> 31 深度和广度优先搜索：如何找出社交网络中的三度好友关系？

### <a name="32"></a> 32 字符串匹配基础（上）：如何借助哈希算法实现高效字符串匹配？

### <a name="33"></a> 33 字符串匹配基础（中）：如何实现文本编辑器中的查找功能？

### <a name="34"></a> 34 字符串匹配基础（下）：如何借助BM算法轻松理解KMP算法

### <a name="35"></a> 35 Trie树：如何实现搜索引擎的搜索关键词提示功能？

### <a name="36"></a> 36 AC自动机：如何用多模式串匹配实现敏感词过滤功能

### <a name="37"></a> 37 贪心算法：如何用贪心算法实现Huffman压缩编码？

### <a name="38"></a> 38 分治算法：谈一谈大规模计算框架MapReduce中的分治思想


### <a name="39"></a> 39 回溯算法：从电影《蝴蝶效应》中学习回溯算法的核心思想


### <a name="40"></a> 40 初识动态规划：如何巧妙解决“双十一”购物时的凑单问题？


### <a name="41"></a> 41 动态规划理论：一篇文章带你彻底搞懂最优子结构、无后效性和重复子问题


### <a name="42"></a> 42 动态规划实战：如何实现搜索引擎中的拼写纠错功能？





		
		